{"version":3,"sources":["../src/init.ts"],"names":["initSecretsStore","pool","secretsTableName","escapeId","databaseName","executeStatement","log","error","Error","message","verbose","stack","debug","databaseNameAsId","secretsTableNameAsId","globalIndexName","AGGREGATE_ID_SQL_TYPE","errorToThrow","code","EventstoreResourceAlreadyExistError","init","eventsTableName","snapshotsTableName","createInitEventStorePromise","result","Promise","all"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AAEA;;;;AAEA,MAAMA,gBAAgB,GAAG,MAAOC,IAAP,IAA2C;AAClE,QAAM;AAAEC,IAAAA,gBAAF;AAAoBC,IAAAA,QAApB;AAA8BC,IAAAA,YAA9B;AAA4CC,IAAAA;AAA5C,MAAiEJ,IAAvE;AACA,QAAMK,GAAG,GAAG,qBAAO,kBAAP,CAAZ;;AAEA,MAAI,CAACJ,gBAAD,IAAqB,CAACC,QAAtB,IAAkC,CAACC,YAAnC,IAAmD,CAACC,gBAAxD,EAA0E;AACxE,UAAME,KAAK,GAAGC,KAAK,CAAE,4CAAF,CAAnB;AACAF,IAAAA,GAAG,CAACC,KAAJ,CAAUA,KAAK,CAACE,OAAhB;AACAH,IAAAA,GAAG,CAACI,OAAJ,CAAYH,KAAK,CAACI,KAAN,IAAeJ,KAAK,CAACE,OAAjC;AACA,UAAMF,KAAN;AACD;;AAEDD,EAAAA,GAAG,CAACM,KAAJ,CAAW,4CAAX;AACAN,EAAAA,GAAG,CAACI,OAAJ,CAAa,qBAAoBR,gBAAiB,EAAlD;AACAI,EAAAA,GAAG,CAACI,OAAJ,CAAa,iBAAgBN,YAAa,EAA1C;AAEA,QAAMS,gBAAgB,GAAGV,QAAQ,CAACC,YAAD,CAAjC;AACA,QAAMU,oBAAoB,GAAGX,QAAQ,CAACD,gBAAD,CAArC;AACA,QAAMa,eAAe,GAAGZ,QAAQ,CAAE,GAAED,gBAAiB,SAArB,CAAhC;;AAEA,MAAI;AACF,UAAMG,gBAAgB,CACnB,8BAA6BQ,gBAAiB,IAAGC,oBAAqB;;eAE9DE,gCAAsB;;;2CAGMD,eAAgB;YAC/CF,gBAAiB,IAAGC,oBAAqB;gBAP3B,CAAtB;AAUD,GAXD,CAWE,OAAOP,KAAP,EAAc;AACd,QAAIA,KAAJ,EAAW;AACT,UAAIU,YAAY,GAAGV,KAAnB;;AACA,UAAK,GAAEA,KAAK,CAACW,IAAK,EAAd,KAAoB,OAAxB,EAAiC;AAC/BD,QAAAA,YAAY,GAAG,IAAIE,0DAAJ,CACZ,0GADY,CAAf;AAGD;;AACDb,MAAAA,GAAG,CAACC,KAAJ,CAAUU,YAAY,CAACR,OAAvB;AACAH,MAAAA,GAAG,CAACI,OAAJ,CAAYO,YAAY,CAACN,KAAzB;AACA,YAAMM,YAAN;AACD;AACF;;AAEDX,EAAAA,GAAG,CAACM,KAAJ,CAAW,+CAAX;AACD,CA7CD;;AA+CA,MAAMQ,IAAI,GAAG,MAAOnB,IAAP,IAA2C;AACtD,QAAMK,GAAG,GAAG,qBAAO,MAAP,CAAZ;AACAA,EAAAA,GAAG,CAACM,KAAJ,CAAU,wBAAV;AAEA,QAAM;AACJR,IAAAA,YADI;AAEJiB,IAAAA,eAFI;AAGJC,IAAAA,kBAHI;AAIJjB,IAAAA,gBAJI;AAKJF,IAAAA;AALI,MAMFF,IANJ;;AAQA,QAAMsB,2BAA2B,GAAG,MAClC,mBAAe;AACbnB,IAAAA,YADa;AAEbiB,IAAAA,eAFa;AAGbC,IAAAA,kBAHa;AAIbjB,IAAAA,gBAJa;AAKbF,IAAAA;AALa,GAAf,CADF;;AASA,QAAMqB,MAAM,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAY,CAC/BH,2BAA2B,EADI,EAE/BvB,gBAAgB,CAACC,IAAD,CAFe,CAAZ,CAArB;AAKAK,EAAAA,GAAG,CAACM,KAAJ,CAAU,2BAAV;AACA,SAAOY,MAAP;AACD,CA5BD;;eA8BeJ,I","sourcesContent":["import { EventstoreResourceAlreadyExistError } from 'resolve-eventstore-base'\nimport getLog from './js/get-log'\nimport initEventStore from './js/init'\nimport { AdapterPool } from './types'\nimport { AGGREGATE_ID_SQL_TYPE } from './js/constants'\n\nconst initSecretsStore = async (pool: AdapterPool): Promise<any> => {\n  const { secretsTableName, escapeId, databaseName, executeStatement } = pool\n  const log = getLog('initSecretsStore')\n\n  if (!secretsTableName || !escapeId || !databaseName || !executeStatement) {\n    const error = Error(`adapter pool was not initialized properly!`)\n    log.error(error.message)\n    log.verbose(error.stack || error.message)\n    throw error\n  }\n\n  log.debug(`initializing secrets store database tables`)\n  log.verbose(`secretsTableName: ${secretsTableName}`)\n  log.verbose(`databaseName: ${databaseName}`)\n\n  const databaseNameAsId = escapeId(databaseName)\n  const secretsTableNameAsId = escapeId(secretsTableName)\n  const globalIndexName = escapeId(`${secretsTableName}-global`)\n\n  try {\n    await executeStatement(\n      `CREATE TABLE IF NOT EXISTS ${databaseNameAsId}.${secretsTableNameAsId} (\n        \"idx\" BIGSERIAL,\n        \"id\" ${AGGREGATE_ID_SQL_TYPE} NOT NULL PRIMARY KEY,\n        \"secret\" text COLLATE pg_catalog.\"default\"\n       );\n       CREATE UNIQUE INDEX IF NOT EXISTS ${globalIndexName}\n       ON ${databaseNameAsId}.${secretsTableNameAsId}\n       (\"idx\");`\n    )\n  } catch (error) {\n    if (error) {\n      let errorToThrow = error\n      if (`${error.code}` === '42P07') {\n        errorToThrow = new EventstoreResourceAlreadyExistError(\n          `duplicate initialization of the postgresql-serverless secrets store with the same parameters not allowed`\n        )\n      }\n      log.error(errorToThrow.message)\n      log.verbose(errorToThrow.stack)\n      throw errorToThrow\n    }\n  }\n\n  log.debug(`secrets store database tables are initialized`)\n}\n\nconst init = async (pool: AdapterPool): Promise<any> => {\n  const log = getLog('init')\n  log.debug('initializing databases')\n\n  const {\n    databaseName,\n    eventsTableName,\n    snapshotsTableName,\n    executeStatement,\n    escapeId,\n  } = pool\n\n  const createInitEventStorePromise = (): Promise<any> =>\n    initEventStore({\n      databaseName,\n      eventsTableName,\n      snapshotsTableName,\n      executeStatement,\n      escapeId,\n    })\n\n  const result = await Promise.all([\n    createInitEventStorePromise(),\n    initSecretsStore(pool),\n  ])\n\n  log.debug('databases are initialized')\n  return result\n}\n\nexport default init\n"],"file":"init.js"}