{"version":3,"sources":["../../src/js/load-events-by-timestamp.js"],"names":["loadEventsByTimestamp","executeStatement","escapeId","escape","eventsTableName","databaseName","shapeEvent","eventTypes","aggregateIds","startTime","finishTime","limit","injectString","value","injectNumber","queryConditions","events","push","map","resultQueryCondition","length","join","databaseNameAsId","eventsTableNameAsId","sqlQuery","rows","event","cursor"],"mappings":";;;;;;;AAAA;;AAEA,MAAMA,qBAAqB,GAAG,OAC5B;AACEC,EAAAA,gBADF;AAEEC,EAAAA,QAFF;AAGEC,EAAAA,MAHF;AAIEC,EAAAA,eAJF;AAKEC,EAAAA,YALF;AAMEC,EAAAA;AANF,CAD4B,EAS5B;AAAEC,EAAAA,UAAF;AAAcC,EAAAA,YAAd;AAA4BC,EAAAA,SAA5B;AAAuCC,EAAAA,UAAvC;AAAmDC,EAAAA;AAAnD,CAT4B,KAUzB;AACH,QAAMC,YAAY,GAAIC,KAAD,IAAY,GAAEV,MAAM,CAACU,KAAD,CAAQ,EAAjD;;AACA,QAAMC,YAAY,GAAID,KAAD,IAAY,GAAE,CAACA,KAAM,EAA1C;;AAEA,QAAME,eAAe,GAAG,EAAxB;AACA,QAAMC,MAAM,GAAG,EAAf;;AACA,MAAIT,UAAU,IAAI,IAAlB,EAAwB;AACtBQ,IAAAA,eAAe,CAACE,IAAhB,CAAsB,cAAaV,UAAU,CAACW,GAAX,CAAeN,YAAf,CAA6B,GAAhE;AACD;;AACD,MAAIJ,YAAY,IAAI,IAApB,EAA0B;AACxBO,IAAAA,eAAe,CAACE,IAAhB,CAAsB,qBAAoBT,YAAY,CAACU,GAAb,CAAiBN,YAAjB,CAA+B,GAAzE;AACD;;AACD,MAAIH,SAAS,IAAI,IAAjB,EAAuB;AACrBM,IAAAA,eAAe,CAACE,IAAhB,CAAsB,kBAAiBH,YAAY,CAACL,SAAD,CAAY,EAA/D;AACD;;AACD,MAAIC,UAAU,IAAI,IAAlB,EAAwB;AACtBK,IAAAA,eAAe,CAACE,IAAhB,CAAsB,kBAAiBH,YAAY,CAACJ,UAAD,CAAa,EAAhE;AACD;;AAED,QAAMS,oBAAoB,GACxBJ,eAAe,CAACK,MAAhB,GAAyB,CAAzB,GAA8B,SAAQL,eAAe,CAACM,IAAhB,CAAqB,OAArB,CAA8B,EAApE,GAAwE,EAD1E;AAGA,QAAMC,gBAAgB,GAAGpB,QAAQ,CAACG,YAAD,CAAjC;AACA,QAAMkB,mBAAmB,GAAGrB,QAAQ,CAACE,eAAD,CAApC;AAEA,QAAMoB,QAAQ,GAAG,CACd,iBAAgBF,gBAAiB,IAAGC,mBAAoB,EAD1C,EAEd,GAAEJ,oBAAqB,EAFT,EAGd,+DAHc,EAId,SAAQ,CAACR,KAAM,EAJD,EAKfU,IALe,CAKV,IALU,CAAjB;AAOA,QAAMI,IAAI,GAAG,MAAMxB,gBAAgB,CAACuB,QAAD,CAAnC;;AAEA,OAAK,MAAME,KAAX,IAAoBD,IAApB,EAA0B;AACxBT,IAAAA,MAAM,CAACC,IAAP,CAAYX,UAAU,CAACoB,KAAD,CAAtB;AACD;;AAED,SAAO;AACL,QAAIC,MAAJ,GAAa;AACX,aAAO,4CAAP;AACD,KAHI;;AAILX,IAAAA;AAJK,GAAP;AAMD,CAtDD;;eAwDehB,qB","sourcesContent":["import { throwBadCursor } from 'resolve-eventstore-base'\n\nconst loadEventsByTimestamp = async (\n  {\n    executeStatement,\n    escapeId,\n    escape,\n    eventsTableName,\n    databaseName,\n    shapeEvent,\n  },\n  { eventTypes, aggregateIds, startTime, finishTime, limit }\n) => {\n  const injectString = (value) => `${escape(value)}`\n  const injectNumber = (value) => `${+value}`\n\n  const queryConditions = []\n  const events = []\n  if (eventTypes != null) {\n    queryConditions.push(`\"type\" IN (${eventTypes.map(injectString)})`)\n  }\n  if (aggregateIds != null) {\n    queryConditions.push(`\"aggregateId\" IN (${aggregateIds.map(injectString)})`)\n  }\n  if (startTime != null) {\n    queryConditions.push(`\"timestamp\" >= ${injectNumber(startTime)}`)\n  }\n  if (finishTime != null) {\n    queryConditions.push(`\"timestamp\" <= ${injectNumber(finishTime)}`)\n  }\n\n  const resultQueryCondition =\n    queryConditions.length > 0 ? `WHERE ${queryConditions.join(' AND ')}` : ''\n\n  const databaseNameAsId = escapeId(databaseName)\n  const eventsTableNameAsId = escapeId(eventsTableName)\n\n  const sqlQuery = [\n    `SELECT * FROM ${databaseNameAsId}.${eventsTableNameAsId}`,\n    `${resultQueryCondition}`,\n    `ORDER BY \"timestamp\" ASC, \"threadCounter\" ASC, \"threadId\" ASC`,\n    `LIMIT ${+limit}`,\n  ].join('\\n')\n\n  const rows = await executeStatement(sqlQuery)\n\n  for (const event of rows) {\n    events.push(shapeEvent(event))\n  }\n\n  return {\n    get cursor() {\n      return throwBadCursor()\n    },\n    events,\n  }\n}\n\nexport default loadEventsByTimestamp\n"],"file":"load-events-by-timestamp.js"}