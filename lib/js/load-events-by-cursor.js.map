{"version":3,"sources":["../../src/js/load-events-by-cursor.js"],"names":["split2RegExp","loadEventsByCursor","executeStatement","escapeId","escape","eventsTableName","databaseName","shapeEvent","eventTypes","aggregateIds","cursor","limit","injectString","value","injectNumber","cursorBuffer","Buffer","from","alloc","vectorConditions","i","length","push","slice","toString","INT8_SQL_TYPE","queryConditions","map","resultQueryCondition","join","threadCounter","threadId","databaseNameAsId","eventsTableAsId","sqlQuery","rows","events","event","oldThreadCounter","parseInt","substring","Math","max","padStart","nextConditionsBuffer","byteIndex","threadCounterBytes","match","byteHex"],"mappings":"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","sourcesContent":["import { INT8_SQL_TYPE } from './constants'\n\nconst split2RegExp = /.{1,2}(?=(.{2})+(?!.))|.{1,2}$/g\n\nconst loadEventsByCursor = async (\n  {\n    executeStatement,\n    escapeId,\n    escape,\n    eventsTableName,\n    databaseName,\n    shapeEvent,\n  },\n  { eventTypes, aggregateIds, cursor, limit }\n) => {\n  const injectString = (value) => `${escape(value)}`\n  const injectNumber = (value) => `${+value}`\n\n  const cursorBuffer =\n    cursor != null ? Buffer.from(cursor, 'base64') : Buffer.alloc(1536, 0)\n  const vectorConditions = []\n  for (let i = 0; i < cursorBuffer.length / 6; i++) {\n    vectorConditions.push(\n      `x'${cursorBuffer\n        .slice(i * 6, (i + 1) * 6)\n        .toString('hex')}'::${INT8_SQL_TYPE}`\n    )\n  }\n\n  const queryConditions = []\n  if (eventTypes != null) {\n    queryConditions.push(`\"type\" IN (${eventTypes.map(injectString)})`)\n  }\n  if (aggregateIds != null) {\n    queryConditions.push(`\"aggregateId\" IN (${aggregateIds.map(injectString)})`)\n  }\n\n  const resultQueryCondition = `WHERE ${\n    queryConditions.length > 0 ? `${queryConditions.join(' AND ')} AND (` : ''\n  }\n    ${vectorConditions\n      .map(\n        (threadCounter, threadId) =>\n          `\"threadId\" = ${injectNumber(\n            threadId\n          )} AND \"threadCounter\" >= ${threadCounter} `\n      )\n      .join(' OR ')}\n    ${queryConditions.length > 0 ? ')' : ''}`\n\n  const databaseNameAsId = escapeId(databaseName)\n  const eventsTableAsId = escapeId(eventsTableName)\n\n  const sqlQuery = [\n    `SELECT * FROM ${databaseNameAsId}.${eventsTableAsId}`,\n    `${resultQueryCondition}`,\n    `ORDER BY \"timestamp\" ASC, \"threadCounter\" ASC, \"threadId\" ASC`,\n    `LIMIT ${+limit}`,\n  ].join('\\n')\n\n  const rows = await executeStatement(sqlQuery)\n  const events = []\n\n  for (const event of rows) {\n    const threadId = +event.threadId\n    const threadCounter = +event.threadCounter\n    const oldThreadCounter = parseInt(\n      vectorConditions[threadId].substring(\n        2,\n        vectorConditions[threadId].length - (INT8_SQL_TYPE.length + 3)\n      ),\n      16\n    )\n\n    vectorConditions[threadId] = `x'${Math.max(\n      threadCounter + 1,\n      oldThreadCounter\n    )\n      .toString(16)\n      .padStart(12, '0')}'::${INT8_SQL_TYPE}`\n\n    events.push(shapeEvent(event))\n  }\n\n  const nextConditionsBuffer = Buffer.alloc(1536)\n  let byteIndex = 0\n\n  for (const threadCounter of vectorConditions) {\n    const threadCounterBytes = threadCounter\n      .substring(2, threadCounter.length - (INT8_SQL_TYPE.length + 3))\n      .match(split2RegExp)\n    for (const byteHex of threadCounterBytes) {\n      nextConditionsBuffer[byteIndex++] = Buffer.from(byteHex, 'hex')[0]\n    }\n  }\n\n  return {\n    cursor: nextConditionsBuffer.toString('base64'),\n    events,\n  }\n}\n\nexport default loadEventsByCursor\n"],"file":"load-events-by-cursor.js"}