{"version":3,"sources":["../../src/js/commit-incremental-import.js"],"names":["commitIncrementalImport","executeStatement","databaseName","eventsTableName","escapeId","escape","importId","validateAfterCommit","incrementalImportTableAsId","incrementalImportTableAsString","threadsTableAsId","eventsTableAsId","databaseNameAsId","databaseNameAsStr","realThreadIdCounters","map","threadId","threadCounter","isNaN","Symbol","predictedThreadIdCounters","validationMapReal","Map","validationMapPredicted","set","validationErrors","get","push","Error","length","compositeError","message","join","stack","error","test"],"mappings":"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","sourcesContent":["const commitIncrementalImport = async (\n  { executeStatement, databaseName, eventsTableName, escapeId, escape },\n  importId,\n  validateAfterCommit\n) => {\n  const incrementalImportTableAsId = escapeId(\n    `${eventsTableName}-incremental-import`\n  )\n  const incrementalImportTableAsString = escape(\n    `${eventsTableName}-incremental-import`\n  )\n  const threadsTableAsId = escapeId(`${eventsTableName}-threads`)\n  const eventsTableAsId = escapeId(eventsTableName)\n  const databaseNameAsId = escapeId(databaseName)\n  const databaseNameAsStr = escape(databaseName)\n\n  try {\n    await executeStatement(`\n      WITH \"ValidateImportId\" AS (\n        SELECT 0 AS \"Zero\" WHERE (\n          (SELECT 1 AS \"IncrementalImportFailed\")\n        UNION ALL\n          (SELECT 1 AS \"IncrementalImportFailed\"\n          FROM \"pg_catalog\".\"pg_class\" \"CLS\"\n          LEFT JOIN \"pg_catalog\".\"pg_description\" \"DESC\"\n          ON \"CLS\".\"oid\" = \"DESC\".\"objoid\"\n          LEFT JOIN \"pg_catalog\".\"pg_namespace\" \"NS\"\n          ON \"CLS\".\"relnamespace\" = \"NS\".\"oid\"\n          WHERE \"DESC\".\"description\" <>\n          ${escape(\n            `RESOLVE INCREMENTAL-IMPORT ${escape(importId)} OWNED TABLE`\n          )}\n          AND \"CLS\".\"relname\" = ${incrementalImportTableAsString}\n          AND \"NS\".\"nspname\" = ${databaseNameAsStr}\n          AND \"CLS\".\"relkind\" = 'r')\n        ) = 1\n      ),\n      \"OriginalUniqueEvents\" AS (\n        SELECT * FROM ${databaseNameAsId}.${incrementalImportTableAsId} WHERE \"rowid\" NOT IN (\n          SELECT \"MaybeEqualEvents\".\"rowid\" FROM (\n            SELECT \"A\".\"payload\" AS \"payloadA\", \"B\".\"payload\" AS \"payloadB\", \"A\".\"rowid\" AS \"rowid\"\n            FROM ${databaseNameAsId}.${incrementalImportTableAsId} \"A\" LEFT JOIN ${databaseNameAsId}.${eventsTableAsId} \"B\" ON\n            \"A\".\"timestamp\" = \"B\".\"timestamp\" AND\n            \"A\".\"aggregateId\" = \"B\".\"aggregateId\" AND\n            \"A\".\"type\" = \"B\".\"type\"\n          ) \"MaybeEqualEvents\"\n          WHERE \"MaybeEqualEvents\".\"payloadA\" = \"MaybeEqualEvents\".\"payloadB\"\n          AND (SELECT \"ValidateImportId\".\"Zero\" FROM \"ValidateImportId\") = 0\n        )\n      ),\n      \"ValidateTimestamps\" AS (\n        SELECT 0 AS \"Zero\" WHERE (\n          (SELECT 1 AS \"IncrementalImportFailed\")\n        UNION ALL\n          (SELECT 1 AS \"IncrementalImportFailed\"\n          FROM ${databaseNameAsId}.${eventsTableAsId}\n          WHERE ${databaseNameAsId}.${eventsTableAsId}.\"timestamp\" > (\n            SELECT MIN(\"OriginalUniqueEvents\".\"timestamp\")\n            FROM \"OriginalUniqueEvents\"\n          )\n          LIMIT 2)    \n        ) = 1\n      ),\n      \"EnumeratedUniqueEvents\" AS (\n        SELECT ROW_NUMBER() OVER (ORDER BY \"OriginalUniqueEvents\".\"timestamp\", \"OriginalUniqueEvents\".\"rowid\") - 1 AS \"sortedIdx\",\n        \"OriginalUniqueEvents\".\"rowid\" as \"rowid\"\n        FROM \"OriginalUniqueEvents\"\n        WHERE (SELECT \"ValidateTimestamps\".\"Zero\" FROM \"ValidateTimestamps\") = 0\n        ORDER BY \"OriginalUniqueEvents\".\"timestamp\"\n      ),\n      \"ThreadTails\" AS (\n        SELECT \"threadId\", MAX(\"threadCounter\") AS \"threadCounter\"  \n        FROM ${databaseNameAsId}.${eventsTableAsId}\n        GROUP BY \"threadId\"\n      ),\n      \"ThreadHeads\" AS (\n        SELECT \"EnumeratedUniqueEvents\".\"sortedIdx\" AS \"sortedIdx\",\n        \"EnumeratedUniqueEvents\".\"rowid\" AS \"rowid\",\n        \"EnumeratedUniqueEvents\".\"sortedIdx\" % 256 AS \"threadId\",\n        COALESCE((\n          SELECT \"ThreadTails\".\"threadCounter\" FROM \"ThreadTails\"\n          WHERE \"ThreadTails\".\"threadId\" = \"EnumeratedUniqueEvents\".\"sortedIdx\" % 256\n        ), -1) + 1 + FLOOR(\"EnumeratedUniqueEvents\".\"sortedIdx\" / 256) AS \"threadCounter\"\n        FROM \"EnumeratedUniqueEvents\"\n      ),\n      \"AggregateTails\" AS (\n        SELECT MAX(\"aggregateVersion\") AS \"aggregateVersion\", \"aggregateId\"  \n        FROM ${databaseNameAsId}.${eventsTableAsId}\n        GROUP BY \"aggregateId\"\n      ),\n      \"OriginalAggregateHeads\" AS (\n        SELECT \"EnumeratedUniqueEvents\".\"sortedIdx\" AS \"sortedIdx\",\n        \"EnumeratedUniqueEvents\".\"rowid\" AS \"rowid\",\n        \"OriginalUniqueEvents\".\"aggregateId\" AS \"aggregateId\",\n        \"OriginalUniqueEvents\".\"timestamp\" AS \"timestamp\",\n         COALESCE((\n          SELECT \"AggregateTails\".\"aggregateVersion\" FROM \"AggregateTails\" \n          WHERE \"AggregateTails\".\"aggregateId\" = \"OriginalUniqueEvents\".\"aggregateId\"\n        ), 0) + 1 AS \"aggregateVersion\" \n        FROM \"OriginalUniqueEvents\" LEFT JOIN \"EnumeratedUniqueEvents\"\n        ON \"OriginalUniqueEvents\".\"rowid\" = \"EnumeratedUniqueEvents\".\"rowid\"\n      ),\n      \"IncrementedAggregateHeads\" AS (\n        SELECT ROW_NUMBER() OVER (PARTITION BY \"OriginalAggregateHeads\".\"aggregateId\" ORDER BY \"OriginalAggregateHeads\".\"timestamp\", \"OriginalAggregateHeads\".\"rowid\") - 1 +  \n        \"OriginalAggregateHeads\".\"aggregateVersion\" AS \"aggregateVersion\",\n        \"OriginalAggregateHeads\".\"rowid\" as \"rowid\"\n        FROM \"OriginalAggregateHeads\"\n        ORDER BY \"OriginalAggregateHeads\".\"sortedIdx\"\n      ),\n      \"InsertionTable\" AS (\n        SELECT \"ThreadHeads\".\"threadId\" AS \"threadId\", \"ThreadHeads\".\"threadCounter\" AS \"threadCounter\",\n        \"OriginalUniqueEvents\".\"timestamp\" AS \"timestamp\", \"OriginalUniqueEvents\".\"aggregateId\" AS \"aggregateId\",\n        \"IncrementedAggregateHeads\".\"aggregateVersion\" AS \"aggregateVersion\",\n        \"OriginalUniqueEvents\".\"type\" AS \"type\", \"OriginalUniqueEvents\".\"payload\" AS \"payload\",\n        \"OriginalUniqueEvents\".\"eventSize\" AS \"eventSize\"\n        FROM \"OriginalUniqueEvents\"\n        LEFT JOIN \"ThreadHeads\" ON \"OriginalUniqueEvents\".\"rowid\" = \"ThreadHeads\".\"rowid\"\n        LEFT JOIN \"IncrementedAggregateHeads\" ON \"OriginalUniqueEvents\".\"rowid\" = \"IncrementedAggregateHeads\".\"rowid\"\n      ),\n      \"ResultTable\" AS (\n        INSERT INTO ${databaseNameAsId}.${eventsTableAsId}(\n          \"threadId\",\n          \"threadCounter\",\n          \"timestamp\",\n          \"aggregateId\",\n          \"aggregateVersion\",\n          \"type\",\n          \"payload\",\n          \"eventSize\"\n        )\n        SELECT * FROM \"InsertionTable\"\n      )\n      UPDATE ${databaseNameAsId}.${threadsTableAsId} \n      SET \"threadCounter\" = GREATEST(\n        ${databaseNameAsId}.${threadsTableAsId}.\"threadCounter\",\n        COALESCE((SELECT MAX(\"InsertionTable\".\"threadCounter\") AS \"threadCounter\"\n        FROM \"InsertionTable\"\n        WHERE \"InsertionTable\".\"threadId\" = ${databaseNameAsId}.${threadsTableAsId}.\"threadId\"\n        ) + 1, 0)\n      )\n    `)\n\n    if (validateAfterCommit != null && validateAfterCommit === true) {\n      const realThreadIdCounters = (\n        await executeStatement(\n          `SELECT \"threadId\", MAX(\"threadCounter\") AS \"threadCounter\"\n        FROM ${databaseNameAsId}.${eventsTableAsId}\n        GROUP BY \"threadId\"\n        `\n        )\n      ).map(({ threadId, threadCounter }) => ({\n        threadId: !isNaN(+threadId) ? +threadId : Symbol('BAD_THREAD_ID'),\n        threadCounter: !isNaN(+threadCounter)\n          ? +threadCounter\n          : Symbol('BAD_THREAD_COUNTER'),\n      }))\n\n      const predictedThreadIdCounters = (\n        await executeStatement(\n          `SELECT \"threadId\", \"threadCounter\"\n        FROM ${databaseNameAsId}.${threadsTableAsId}`\n        )\n      ).map(({ threadId, threadCounter }) => ({\n        threadId: !isNaN(+threadId) ? +threadId : Symbol('BAD_THREAD_ID'),\n        threadCounter: !isNaN(+threadCounter)\n          ? +threadCounter\n          : Symbol('BAD_THREAD_COUNTER'),\n      }))\n\n      const validationMapReal = new Map()\n      const validationMapPredicted = new Map()\n\n      for (const { threadId, threadCounter } of realThreadIdCounters) {\n        validationMapReal.set(threadId, threadCounter)\n      }\n      for (const { threadId, threadCounter } of predictedThreadIdCounters) {\n        validationMapPredicted.set(threadId, threadCounter)\n      }\n\n      const validationErrors = []\n\n      for (const { threadId, threadCounter } of realThreadIdCounters) {\n        if (validationMapPredicted.get(threadId) !== threadCounter + 1) {\n          validationErrors.push(\n            new Error(\n              `Real -> Predicted threadCounter mismatch ${threadId} ${threadCounter} ${validationMapPredicted.get(\n                threadId\n              )}`\n            )\n          )\n        }\n      }\n      for (const { threadId, threadCounter } of predictedThreadIdCounters) {\n        if (\n          validationMapReal.get(threadId) !== threadCounter - 1 &&\n          validationMapReal.get(threadId) != null\n        ) {\n          validationErrors.push(\n            new Error(\n              `Predicted -> Real threadCounter mismatch ${threadId} ${threadCounter} ${validationMapReal.get(\n                threadId\n              )}`\n            )\n          )\n        }\n      }\n\n      if (validationErrors.length > 0) {\n        const compositeError = new Error(\n          validationErrors.map(({ message }) => message).join('\\n')\n        )\n        compositeError.stack = validationErrors\n          .map(({ stack }) => stack)\n          .join('\\n')\n        throw compositeError\n      }\n    } else if (validateAfterCommit != null) {\n      throw new Error('Bad argument for \"validateAfterCommit\"')\n    }\n  } catch (error) {\n    if (\n      error != null &&\n      (/Table.*? does not exist$/i.test(error.message) ||\n        /subquery used as an expression/i.test(error.message))\n    ) {\n      throw new Error(\n        `Either event batch has timestamps from the past nor incremental importId=${importId} does not exist`\n      )\n    } else {\n      throw error\n    }\n  } finally {\n    await executeStatement(\n      `DROP TABLE IF EXISTS ${databaseNameAsId}.${incrementalImportTableAsId};`\n    )\n  }\n}\n\nexport default commitIncrementalImport\n"],"file":"commit-incremental-import.js"}